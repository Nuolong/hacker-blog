---	
layout: default	
title: "05: Lisp is the betht!"	
date: 2021-03-13 12:00:00 -0000	
categories:	
---

## 05: Lisp is the betht!

Paul Graham starts to make some good points, that to be successful in a software startup is to do something no one else has done before, and notes that the programming language you choose to develop that software has to be "above-average." He writes, "when you choose technology, you have to ignore what other people are doing, and consider only what will work the best." Then he goes on to single out how great Lisp is specifically, and how his startup was able to out-program all his competitors because of that. At the same time he dismisses commonly used languages like Perl or C. While I do like the generalized point he made about doing something no one else has done before, I don't care for how much he's focusing on how great and successful Lisp was for him to use. He seems pretty narrow-minded, since it seems like he's ignoring all other programming languages as inferior. What if certain other hackers were so great using a different language in their startup and was able to output as fast as their Viaweb startup was (note: different languages given the same problems to solve)? He doesn't give any mind to the possibility that maybe these competitors are just not as much of a hacker he is, or maybe they're working on such a bigger scale that actual developing takes longer to get started, which I do believe is something he's previously mentioned in another essay. Instead of staying consistent with his arguments, he's now creating a localized argument where everything is being attributed to the language programmers are using.

But then, Graham starts talking about the idea of the "Blub" programming language. He says "programming languages vary in power." I can agree with that. He describes Blub as an average language that is held in Blub programmers' hearts. Looking down at languages weaker than Blub, an average Blub programmer would say "It doesn't even have x!" Looking at potentially stronger languages, however, the programmer would be oblivious. This applies to more and more powerful languages, with each respective programmer looking down at other languages and saying stuff like "these other languages don't even have XYZ!" However, Graham then brings induction into the picture for some reason, and claims that there must be a single language in the hierarchy that is the most powerful of all, alongside its users who are able to see the entire hierarchy below them. Uh, ok, Graham. Sounds a bit contradictory. You called this a paradox yourself, so how do you know there wouldn't be a programming language even _more_ powerful than the one _you_ thought was the best? Then he tries to be relatable and say how he used to program in Basic and thought he was the best, though later realized that Lisp was actually king. He goes on: "What I will say is that I think Lisp is at the top. And to support this claim I'll tell you about one of the things I find missing when I look at the other four languages." Wait a minute. Are you joking? You literally just explained this "power continuum" of how programmers are delusional thinking their Blub language is the best, seeing how other languages "don't have XYZ," and now you think you can use the same "delusional" line of thought to support your "Lisp is the best" claim? Sir, I'm not sure if you're being serious with this because I'm literally still learning how to read, but don't you think that _maybe_ Lisp is your own Blub? Just because Lisp worked so well for you doesn't mean it's the GOAT.

So while I do like Graham's points about "doing something different" to be successful, and the whole idea of a "Blub" programming language, I'd rather just leave it at that without specifying. It's nicer to think of Blub and the entire language continuum as theoretical rather than substituting actual languages, because I believe all languages are great and powerful, but that it just needs the right person to use it the best possible way. I just can't deal with Graham's Lisp shilling; he's a total goober and it's so cringe.

Graham, in his next essay, goes to talk about language design and how the way technologies are made through programming languages will slowly shift as our hardware grows faster and faster. He makes a great point: "In language design, we should be consciously seeking out situations where we can trade efficiency for even the smallest increase in convenience." But what if one of the reasons computers get faster in the first place is due to the little optimizations programmers make here and there? Then he makes a good point: "What's gross is a language that makes programmers do needless work. Wasting programmer time is the true inefficiency, not wasting machine time." I agree with this for sure, except now I'm confused about what Graham's point is. So is he talking about how long it takes a programmer to make something or how long it takes to execute the program? With what he just said about computers running faster and faster as years go on, it seems like he's talking about the latter. But now he's like, _actually_, the problem is the former. _Maybe_ he's saying that languages need to be super easy and quick to write, and that to achieve that, it's okay to sacrifice the time it takes for that program to compile or execute because computers will always be getting faster in the first place. But then that brings me back to my first question, about how computers even do get faster in the first place. Sure, there's things having to do with hardware and Moore's law and whatnot, but how about the low level software on the computers we use? Surely there needs to be a good amount of attention on writing efficient code in that case? Graham seems to be pushing his argument onto everyone, but it seems like there still needs to be certain programmers who can't rely on writing inefficient code for the future. Overall, I don't like how vague his arguments are here. He tells us that it'd be great to start making such an ideal language that'll be great in a hundred years as if it were the easiest thing ever. Why don't you do it yourself, then? I don't care about creating the next revolutionary language! He does make some points I can get behind in the beginning, though. It's a good thought to have when exploring these new upcoming programming languages, about how some of them may become the next big thing.

Next essay, and bruh, he's still mentioning Lisp. He's already lost my trust from the first essay that anything he says about Lisp is legitimate, so his efforts in trying to convince me how pog Lisp is is actually just making me more annoyed at it. Jokes aside, okay, okay, I get it. Lisp was a pioneer of programming languages, and you were such a genius for recognizing it early on.

Quote: "...because the time it takes to write a program depends mostly on its length." I disagree! Doesn't writing shorter code take longer? Like, aren't inefficient programs generally long but easy to write? Or is Graham so big brain that he only writes short and powerful code in... you guessed it... Lisp? 

Maybe my annoyance with Graham for some of the points he's trying to make is due to my subconscious herd mentality. I see a majority of the class getting annoyed with his essays, so I can't think for myself and just follow along, conforming to the same ideas because I'll be blasted if I actually turn around and agree with everything he's saying. Well, at least that's what _he_ would say is happening.

### [<center>Home</center>](https://nuolong.github.io/hacker-blog/)
